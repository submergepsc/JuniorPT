# pt5 题解概览

## InsertStr.cpp
- **题目背景**：把一个子串插入到主串的指定位置，若插入位置不在有效范围内，需要自动修正。
- **实现要点**：先用 `getline` 读取两行原始文本，再读取整数下标。通过简单的 `if` 判断把下标限制在 `[0, mainStr.size()]` 范围内，然后调用 `string::insert` 将子串插入，无需依赖 `std::clamp` 等更进阶的函数。
- **复杂度**：插入操作需要移动后半段字符，时间复杂度为 O(n)。

## pailie.cpp
- **题目背景**：输入 `n`（2≤n≤9）个整数，输出一个 `n×n` 的循环平移矩阵。
- **实现要点**：保持原数组不动，使用双层循环和 `(i + j) % n` 的索引计算直接访问对应元素。整个过程只使用基本的算术运算，没有额外的辅助结构。
- **复杂度**：需要输出 `n²` 个元素，因此时间复杂度 O(n²)。

## mostWater.cpp
- **题目背景**：在给定的高度数组中选择两根竖线，使它们和 x 轴围成的容器面积最大。
- **实现要点**：使用双指针从两端向中间靠拢，每步仅用条件语句比较两端高度，避免 `std::min` 或 `std::max`。移动较短的一侧可探索更大的容器宽度，同时保留当前最大面积。
- **复杂度**：每次循环都会缩短指针距离一次，整体复杂度 O(n)。

## brackets.cpp
- **题目背景**：判断表达式中的 `{}`、`[]`、`()` 是否完全匹配。
- **实现要点**：借助 `stack<char>` 保存还未匹配的左括号，遇到右括号时用 if 语句逐一判断三种合法配对情况；栈为空且过程未提前返回，即判定为匹配。
- **复杂度**：扫描字符串一次即可完成判断，时间复杂度 O(n)。

## monkey.cpp
- **题目背景**：经典约瑟夫问题：`n` 只猴子围成圈按 `m` 报数，报到 `m` 的猴子离开，求最后留下的编号。
- **实现要点**：用 `vector<int>` 顺序存储猴子编号，每次通过 `(index + m - 1) % size` 找到需要删除的对象。删除后直接继续循环，无需额外数据结构。
- **复杂度**：需要执行 `n-1` 次删除操作，每次删除在向量上是线性的，因此近似 O(nm)。

## monkeyLink.cpp
- **题目背景**：以链表形式再次求解约瑟夫问题，练习指针操作。
- **实现要点**：手动构造循环单链表，并维护前驱指针以在 O(1) 时间删除节点。每轮移动 `m-1` 步后将当前节点剔除，再继续下一轮，直到只剩一个节点。
- **复杂度**：同样需要执行 `n-1` 次删除，时间复杂度 O(nm)，但每次删除的开销更低。

## IPO.cpp
- **题目背景**：在最多选择 `k` 个项目的前提下，使最终资本最大。每个项目有启动成本和收益。
- **实现要点**：先按启动资本对项目排序，再使用 `priority_queue`（标准库中的最大堆容器适配器）存储当前可以启动的项目利润。每轮弹出堆顶最大利润并更新资本，然后继续加入新可选项目，直到选满或堆为空。
- **复杂度**：排序 O(n log n)，堆操作总次数不超过 `k` 次，同样为对数复杂度，总体可看作 O(n log n)。
