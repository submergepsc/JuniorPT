# pt1 题解概览

## Pi.cpp
- **题目背景**：利用莱布尼茨公式 `π/4 = 1 - 1/3 + 1/5 - ...` 近似圆周率，直到级数中的最新一项绝对值小于 `1e-8` 为止。
- **实现要点**：通过普通的 `while` 循环不断累加交替符号的分式，使用整型变量 `sign` 在 `1` 与 `-1` 之间切换即可，不需要 `pow` 这类额外函数。循环结束后借助 `iomanip` 设置小数位数，再输出乘以 4 的结果以及使用的项数。
- **复杂度与精度**：莱布尼茨级数收敛速度较慢，满足精度约需要几十万项，但题目约束允许；时间复杂度约为 O(1/eps)。

## ShapeEx.cpp
- **题目背景**：输入正整数 `n`，打印一个由 `2n-1` 行星号组成的对称菱形，中间一行最宽。
- **实现要点**：上半部分从 1 行开始逐渐增加到 `n` 行，下半部分倒序输出即可。利用 `string(count, '*')` 快速构造一整行的字符，比逐个字符输出更简洁。
- **复杂度**：输出的星号数与 `n^2` 同阶，因此时间复杂度为 O(n²)，空间只使用常数级额外变量。

## CountChar.cpp
- **题目背景**：读取一整行文本，统计每个字符出现次数并以 `字符=次数` 的形式输出，字符之间用空格分隔。
- **实现要点**：`getline` 能读取含空格的整行文本；将计数存入 `map<char,int>`，利用它按键自动排序的特性，最后使用范围循环输出即可。代码只涉及基础循环和条件语句，结构直观。
- **复杂度**：遍历字符串一次，复杂度约为 O(L log σ)，其中 `L` 为行长度，`σ` 为不同字符数。

## CountDigit.cpp
- **题目背景**：编写函数 `countDigit` 统计一个整数中数字 0~9 各自出现的次数。
- **实现要点**：使用 `array<int,10>` 保存计数，先处理输入为 0 的特例，随后对 `n` 取绝对值，循环执行取模和整除。全部逻辑只依赖四则运算和数组操作，适合初学者理解。
- **复杂度**：数字位数为 `log10 n`，因此时间复杂度为 O(log n)。

## Huiwen.cpp
- **题目背景**：判断一个非负整数从前往后与从后往前读是否一致。
- **实现要点**：保留原数，使用简单的取模与乘法反转数字，循环结束后比较反转结果与原数即可。整个过程仅用到基本算术运算，没有额外数据结构。
- **复杂度**：处理的位数即循环次数，复杂度为 O(log n)。

## candy.cpp
- **题目背景**：每个孩子有评分，评分更高的孩子必须拿到比相邻同学更多的糖果，求满足条件的最小糖果总数。
- **实现要点**：先从左向右遍历数组，保证评分上升时糖果数也递增；再从右向左检查下降趋势，必要时手动比较并更新糖果数量，而不是依赖 `std::max`。最后用一次简单的 `for` 循环求和，避免使用较难理解的 `accumulate`。
- **复杂度**：两趟线性扫描即可完成，时间复杂度 O(n)，额外使用一个与人数等长的向量存储糖果分配。
