# pt8 题解概览

## PickMatch.cpp
- **题目背景**：桌上共有 21 根火柴，两名玩家轮流各取 1~4 根，不能弃权。谁拿到最后一根就输。人类玩家先手，计算机需要保持“常胜”。
- **实现要点**：枚举可以发现当剩余火柴为 1、6、11、16、21 根时，轮到操作的一方必输。计算机每次行动时根据当前剩余数量计算应取火柴数，让局面回到这些“必败点”。读取人类输入时通过循环反复提示，保证只接受 1~4 且不超过剩余数量的取法。
- **复杂度**：游戏每一回合只包含常数次运算，总体复杂度为 O(回合数)，最多 21/2≈11 回合结束。

## meetChess.cpp
- **题目背景**：在 7×7 的黑白棋盘上，棋子 A 只能停留在黑格，棋子 B 只能停留在白格。两子从给定起点出发，每轮分别随机移动一步（可走到同色的 8 邻格），需要输出两子每轮的位置，直到两子所在的格子彼此相邻为止。
- **实现要点**：为了使颜色限制可判定，将“黑格”定义为行列和为偶数的格子。程序先读取两子的起始坐标并验证颜色合法性，再用 `mt19937` 随机数引擎在所有合法邻接格子中等概率选取下一步。通过自定义函数手动计算坐标差值，判断两子是否已经处在相邻的 8 邻位置。
- **复杂度**：每轮枚举至多 8 个候选格子，并进行一次随机挑选，时间复杂度 O(轮数)。棋盘有限，因此最终必然停止。

## Queen.cpp
- **题目背景**：经典的八皇后问题，需要在 8×8 棋盘上摆放 8 个皇后，使得任意两皇后都不在同一行、同一列或同一条对角线上。
- **实现要点**：使用回溯法逐行尝试放置皇后。`positions[row]` 记录第 `row` 行皇后的列号，检查新皇后时仅需比较列冲突与两条对角线冲突。找到完整布局后即时输出棋盘的字符表示（`Q` 和 `.`），并统计解的数量。
- **复杂度**：回溯树的深度为 8，每层最多尝试 8 种列位置，最坏情况下复杂度约为 O(8!)，但剪枝后运行迅速，可在瞬间枚举完全部 92 个解。

